---
task_id: "2026-02-05T1002-backend-dev-routing-integration"
created: "2026-02-05T10:00:00Z"
assigned_to: "backend-dev"
priority: "HIGH"
status: "ready"
batch: "M2 Batch 2.3 - Generic YAML Adapter"
estimated_hours: 2.5

title: "Integrate GenericYAMLAdapter with Routing Engine"

context: |
  GenericYAMLAdapter (Task 1) and ENV variable support (Task 2) are complete.
  Routing engine currently expects adapter factory to return concrete adapter
  instances. Need to update routing engine to use GenericYAMLAdapter for all tools.
  
  This task replaces concrete adapter usage with generic adapter, making the
  routing engine fully YAML-driven without tool-specific code.

objective: |
  Update routing engine and adapter factory to use GenericYAMLAdapter for all
  tools, demonstrating YAML-driven extensibility. Remove dependency on concrete
  adapters (except ClaudeCodeAdapter as test fixture).

requirements:
  - Update AdapterFactory to create GenericYAMLAdapter instances
  - Pass tool_name and tool_config to GenericYAMLAdapter constructor
  - Remove concrete adapter imports (except for tests)
  - Update routing engine tests to use GenericYAMLAdapter
  - Validate routing works with multiple tools (claude-code, codex via YAML)
  - Maintain >80% test coverage on routing engine
  - Integration tests demonstrate adding new tool via YAML

deliverables:
  - file: "src/llm_service/routing/adapter_factory.py"
    description: "Updated adapter factory using GenericYAMLAdapter"
    changes:
      - "Replace concrete adapter classes with GenericYAMLAdapter"
      - "get_adapter(tool_name) -> GenericYAMLAdapter(tool_name, tool_config)"
      - "Remove ClaudeCodeAdapter, CodexAdapter imports (production code)"
    code_sample: |
      class AdapterFactory:
          def __init__(self, config_loader: ConfigLoader):
              self.config_loader = config_loader
          
          def get_adapter(self, tool_name: str) -> ToolAdapter:
              """Get adapter for specified tool."""
              tool_config = self.config_loader.get_tool_config(tool_name)
              if not tool_config:
                  raise ToolNotFoundError(f"Tool {tool_name} not in config")
              
              # Use generic adapter for ALL tools
              return GenericYAMLAdapter(tool_name, tool_config)
    
  - file: "src/llm_service/routing/engine.py"
    description: "Updated routing engine (if needed)"
    changes:
      - "Ensure routing engine uses adapter_factory.get_adapter()"
      - "No tool-specific logic in routing"
      - "All tool behavior driven by YAML config"
    
  - file: "tests/unit/routing/test_adapter_factory.py"
    description: "Updated adapter factory tests"
    test_coverage:
      - "test_get_adapter_creates_generic_adapter" - Returns GenericYAMLAdapter
      - "test_get_adapter_different_tools" - Works for multiple tools
      - "test_tool_not_found_error" - Clear error for unknown tool
      - "test_adapter_has_correct_config" - Config passed correctly
    
  - file: "tests/integration/routing/test_end_to_end_routing.py"
    description: "End-to-end routing tests with GenericYAMLAdapter"
    test_scenarios:
      - "test_route_claude_code_request" - Route to claude-code via YAML
      - "test_route_codex_request" - Route to codex via YAML (new tool)
      - "test_route_with_env_vars" - ENV variables passed correctly
      - "test_add_new_tool_via_yaml" - Add gemini-cli via YAML only
    
  - file: "config/tools.yaml.example"
    description: "Add example tool (codex) to demonstrate extensibility"
    example: |
      codex:
        binary: codex
        command_template: "{binary} --model {model} --input {prompt_file}"
        models:
          - gpt-4-turbo
          - gpt-3.5-turbo
        platforms:
          linux: /usr/local/bin/codex
          macos: /usr/local/bin/codex

technical_approach: |
  1. Update AdapterFactory (src/llm_service/routing/adapter_factory.py):
     - Remove concrete adapter imports (ClaudeCodeAdapter, etc.)
     - Import only: GenericYAMLAdapter, ToolAdapter (base)
     - get_adapter() creates GenericYAMLAdapter with tool_config
     - Validation: Tool exists in config, config is valid
  
  2. Update RoutingEngine (if needed):
     - Verify it uses adapter_factory.get_adapter(tool_name)
     - No tool-specific conditionals in routing logic
     - Policy-based routing (from YAML config)
  
  3. Update tests:
     - Unit tests: Verify factory creates GenericYAMLAdapter
     - Integration tests: End-to-end routing with real YAML config
     - Add test for "new tool via YAML" (e.g., gemini-cli)
  
  4. Update example configs:
     - Add codex tool definition to tools.yaml.example
     - Show how to add new tool without code changes
  
  5. Clean up imports:
     - Production code: Only import GenericYAMLAdapter
     - Test code: Can import ClaudeCodeAdapter for test fixtures

dependencies:
  - "Task 1: GenericYAMLAdapter COMPLETE" - Production adapter ready
  - "Task 2: ENV vars COMPLETE" - Schema supports ENV variables
  - "M2 Batch 2.1: COMPLETE" - Routing engine exists

success_criteria:
  - AdapterFactory creates GenericYAMLAdapter for all tools
  - Routing engine tests pass with GenericYAMLAdapter
  - No concrete adapter imports in production code (except test fixtures)
  - Integration test demonstrates adding new tool via YAML
  - >80% test coverage maintained on routing engine
  - Documentation shows how to add tools via YAML

validation_checklist:
  - "Routing works for claude-code (existing tool)" - ✓
  - "Routing works for codex (new tool added via YAML)" - ✓
  - "ENV variables passed to adapter correctly" - ✓
  - "Tool not found error is user-friendly" - ✓
  - "No tool-specific code in routing engine" - ✓
  - "ClaudeCodeAdapter only imported in tests" - ✓

integration_tests:
  test_add_new_tool_yaml_only:
    description: "Demonstrate adding gemini-cli via YAML without code changes"
    steps:
      1. "Add gemini-cli to config/tools.yaml.example"
      2. "Load config"
      3. "Get adapter via factory"
      4. "Verify GenericYAMLAdapter created with correct config"
      5. "Execute request (with mocked binary)"
    expected: "Request succeeds, proving YAML-driven extensibility"

references:
  - "src/llm_service/routing/adapter_factory.py" - Current factory
  - "src/llm_service/routing/engine.py" - Routing engine
  - "src/llm_service/adapters/generic_adapter.py" - GenericYAMLAdapter
  - "work/analysis/generic-yaml-adapter-architecture-review.md" - Design

notes: |
  This task completes the M2 Batch 2.3 strategic pivot. After this, adding new
  tools requires YAML changes only, no code changes. This is the key extensibility
  goal for the LLM Service Layer.
  
  ClaudeCodeAdapter is kept in codebase but only used in test fixtures. It serves
  as documentation and validation that the infrastructure works correctly.

migration_notes: |
  Breaking changes: None (backward compatible)
  - Existing tool configs work without changes
  - AdapterFactory interface unchanged (get_adapter returns ToolAdapter)
  - Routing engine interface unchanged
  
  Code removal:
  - Concrete adapter imports from production code (keep in tests)
  - Tool-specific conditionals in adapter factory (if any)

time_breakdown:
  adapter_factory_update: "45 minutes"
  routing_engine_validation: "30 minutes"
  test_updates: "1 hour"
  integration_tests: "45 minutes"
  documentation: "30 minutes"
  total: "3.5 hours"

risks:
  - risk: "Routing engine has tool-specific logic we haven't seen"
    mitigation: "Review routing engine code first, refactor if needed"
    impact: "MEDIUM - May add 1-2 hours"
  
  - risk: "Tests depend on concrete adapter behavior"
    mitigation: "Update tests to use GenericYAMLAdapter or test fixtures"
    impact: "LOW - Tests are flexible"
---
