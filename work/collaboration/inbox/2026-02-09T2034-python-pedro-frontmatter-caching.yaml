---
id: 2026-02-09T2034-python-pedro-frontmatter-caching
agent: python-pedro
status: new
priority: high
phase: implementation
specification: specifications/initiatives/dashboard-enhancements/orphan-task-assignment.md
feature: "FEAT-DASH-008-02: Interactive Specification/Feature Selector"
title: "Backend: Specification Frontmatter Caching Layer"
created: 2026-02-09T20:34:00Z
created_by: planning-petra
estimated_hours: 1
artefacts:
  - src/llm_service/dashboard/spec_cache.py
  - src/llm_service/dashboard/portfolio_builder.py
description: |
  # Task: Specification Frontmatter Caching Layer
  
  ## Context
  
  **Specification:** SPEC-DASH-008 v1.0.0
  **Architecture Review:** APPROVED
  **Performance Requirement:** NFR-P2 - Frontmatter parsing <200ms for 50+ specifications
  
  **Architectural Decision:**
  - Implement two-tier caching strategy
  - Tier 1: In-memory cache (process lifetime)
  - Tier 2: File watcher invalidation (watchdog library)
  
  ## Objective
  
  Create caching layer for specification frontmatter parsing to meet performance budget:
  - Initial load (startup): <2 seconds for 50 specs
  - Cached reads: <50ms
  - Cache invalidation: <100ms
  
  ## Acceptance Criteria (ATDD)
  
  **AC1: Cache Specification Frontmatter**
  ```gherkin
  Given I have 50 specification files
  When the system starts up
  Then all specification frontmatter is parsed and cached within 2 seconds
  And subsequent reads complete in <50ms
  ```
  
  **AC2: Invalidate Cache on File Change**
  ```gherkin
  Given I have cached specification frontmatter
  When a specification file is modified
  Then the cache for that specification is invalidated within 100ms
  And the next read re-parses the frontmatter
  ```
  
  **AC3: Handle Missing Specifications Gracefully**
  ```gherkin
  Given I have a cached specification list
  When a specification file is deleted
  Then the cache removes that specification entry
  And no error is raised
  And the specification does not appear in the initiative list
  ```
  
  ## Implementation Guidance
  
  ### Cache Implementation
  ```python
  # src/llm_service/dashboard/spec_cache.py
  
  class SpecificationCache:
      def __init__(self):
          self.cache = {}  # {spec_path: {frontmatter, modified_time}}
          self.file_watcher = None
          
      def get_spec(self, spec_path):
          """Get cached specification frontmatter or parse if not cached."""
          if spec_path in self.cache:
              return self.cache[spec_path]['frontmatter']
          return self._parse_and_cache(spec_path)
      
      def invalidate(self, spec_path):
          """Invalidate cache entry for specified path."""
          if spec_path in self.cache:
              del self.cache[spec_path]
      
      def start_file_watcher(self):
          """Start watchdog file watcher for specifications/ directory."""
          from watchdog.observers import Observer
          from watchdog.events import FileSystemEventHandler
          
          class SpecChangeHandler(FileSystemEventHandler):
              def __init__(self, cache):
                  self.cache = cache
              
              def on_modified(self, event):
                  if event.src_path.endswith('.md'):
                      self.cache.invalidate(event.src_path)
          
          self.file_watcher = Observer()
          self.file_watcher.schedule(
              SpecChangeHandler(self),
              'specifications/',
              recursive=True
          )
          self.file_watcher.start()
  ```
  
  ### Integration with Portfolio Builder
  ```python
  # Modify src/llm_service/dashboard/portfolio_builder.py
  
  from spec_cache import SpecificationCache
  
  spec_cache = SpecificationCache()
  spec_cache.start_file_watcher()
  
  def get_initiative_list():
      """Return cached specification list for assignment modal."""
      specs = []
      for spec_file in glob.glob('specifications/**/*.md', recursive=True):
          frontmatter = spec_cache.get_spec(spec_file)
          specs.append({
              'path': spec_file,
              'title': frontmatter.get('title'),
              'initiative': frontmatter.get('initiative'),
              'features': frontmatter.get('features', [])
          })
      return specs
  ```
  
  ### Testing Strategy
  - **Unit Tests:** Cache hit/miss, invalidation, file watching
  - **Performance Tests:** 
    - Initial load time <2s for 50 specs
    - Cached read time <50ms
    - Invalidation time <100ms
  - **Integration Tests:** End-to-end with portfolio API
  
  ## Dependencies
  - Package: `watchdog` (already in dependencies)
  - Runs independently (can be implemented before or after backend endpoint)
  
  ## Handoff
  **Next:** Integrate with backend endpoint and frontend modal
