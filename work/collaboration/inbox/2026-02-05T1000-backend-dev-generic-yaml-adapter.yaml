---
task_id: "2026-02-05T1000-backend-dev-generic-yaml-adapter"
created: "2026-02-05T10:00:00Z"
assigned_to: "backend-dev"
priority: "HIGH"
status: "ready"
batch: "M2 Batch 2.3 - Generic YAML Adapter"
estimated_hours: 3

title: "Implement GenericYAMLAdapter for Tool Extensibility"

context: |
  M2 Batches 2.1 & 2.2 are complete. Strategic pivot to generic YAML-driven adapter
  approach approved (ADR-029 updated 2026-02-05). ClaudeCodeAdapter is kept as
  reference implementation and test fixture.
  
  This task implements the PRODUCTION adapter that works with any tool defined in
  YAML configuration, eliminating the need for tool-specific adapter classes.

objective: |
  Create GenericYAMLAdapter that reads tool configuration from YAML and executes
  any external LLM tool without requiring code changes. This becomes the primary
  production adapter used by the routing engine.

requirements:
  - Single adapter class works with ANY tool defined in YAML
  - Reads binary path, command template, models from ToolConfig
  - Binary resolution: check config, then shutil.which(), then platform paths
  - Command generation via existing TemplateParser from Batch 2.1
  - ENV variable support from YAML configuration
  - Model validation against tool's supported models list
  - Error handling with user-friendly messages
  - Integration with existing SubprocessExecutor and OutputNormalizer

deliverables:
  - file: "src/llm_service/adapters/generic_adapter.py"
    description: "GenericYAMLAdapter class extending ToolAdapter base"
    key_features:
      - "__init__(tool_name, tool_config)" - Constructor takes tool config
      - "execute(prompt, model, params)" - Main execution method
      - "_resolve_binary()" - Binary path resolution (config > which > platform)
      - "_prepare_env(params)" - ENV variable preparation from config + params
      - "_validate_model(model)" - Check model in tool's supported list
    
  - file: "tests/unit/adapters/test_generic_adapter.py"
    description: "Unit tests for GenericYAMLAdapter"
    test_coverage:
      - "test_execute_success" - Happy path execution
      - "test_binary_resolution_from_config" - Config override works
      - "test_binary_resolution_from_path" - shutil.which() fallback
      - "test_binary_not_found_error" - Clear error message
      - "test_invalid_model_error" - Model validation
      - "test_env_variable_preparation" - ENV vars from config
    coverage_target: ">80%"

technical_approach: |
  1. Create GenericYAMLAdapter class in src/llm_service/adapters/generic_adapter.py:
     ```python
     class GenericYAMLAdapter(ToolAdapter):
         def __init__(self, tool_name: str, tool_config: ToolConfig):
             self.tool_name = tool_name
             self.tool_config = tool_config
             self.template_parser = TemplateParser()
             self.subprocess_executor = SubprocessExecutor()
             self.output_normalizer = OutputNormalizer()
         
         def execute(self, prompt: str, model: str, params: Dict = None) -> ToolResponse:
             # 1. Validate model
             # 2. Resolve binary path
             # 3. Generate command from template
             # 4. Prepare environment variables
             # 5. Execute via subprocess
             # 6. Normalize output
             # 7. Return ToolResponse
     ```
  
  2. Binary resolution priority:
     - tool_config.binary_path (if set) - highest priority
     - shutil.which(tool_config.binary) - system PATH
     - tool_config.platforms[current_platform] - platform-specific default
     - Raise BinaryNotFoundError if not found
  
  3. ENV variable handling:
     - Start with os.environ.copy()
     - Add tool_config.env_vars if defined (future enhancement)
     - Override with params["env"] if provided
     - Return merged environment dictionary
  
  4. Command generation:
     - Use existing TemplateParser from Batch 2.1
     - Context: {binary, model, prompt, ...custom params}
     - Parse tool_config.command_template with context
  
  5. Error handling:
     - BinaryNotFoundError: "Tool '{tool_name}' binary not found. Install..."
     - InvalidModelError: "Model '{model}' not supported. Available: ..."
     - ExecutionError: Pass through from SubprocessExecutor with context

dependencies:
  - "M2 Batch 2.1: COMPLETE" - Base infrastructure (ToolAdapter, TemplateParser, SubprocessExecutor)
  - "M2 Batch 2.2: COMPLETE" - Reference implementation validates infrastructure

success_criteria:
  - GenericYAMLAdapter passes all unit tests (>80% coverage)
  - Works with claude-code tool (using existing YAML config)
  - Demonstrates adding a NEW tool via YAML without code changes
  - Clear error messages for common failures (binary not found, invalid model)
  - Ready for routing engine integration

next_steps:
  - After completion: Task 2 (ENV variable YAML schema enhancement)
  - After Task 2: Task 3 (Routing engine integration)

references:
  - "ADR-029: Adapter Interface Design (updated 2026-02-05)"
  - "work/analysis/generic-yaml-adapter-architecture-review.md"
  - "src/llm_service/adapters/base.py" - ToolAdapter base class
  - "src/llm_service/adapters/claude_code_adapter.py" - Reference implementation
  - "src/llm_service/adapters/command_template.py" - TemplateParser
  - "src/llm_service/adapters/subprocess_executor.py" - SubprocessExecutor

notes: |
  This is the KEY deliverable for M2 Batch 2.3. ClaudeCodeAdapter becomes test-only
  after this. GenericYAMLAdapter is the production implementation that enables
  YAML-driven tool extensibility without code changes.
  
  Design philosophy: Convention over configuration. Smart defaults with override
  capability. User-friendly error messages that suggest solutions.

risks:
  - risk: "ENV variable support not in current YAML schema"
    mitigation: "Task 2 addresses schema enhancement. Use params override for now."
    impact: "LOW - workaround available"
  
  - risk: "Tool-specific output parsing might need customization"
    mitigation: "OutputNormalizer already supports tool-specific logic via tool_name"
    impact: "LOW - infrastructure supports it"

time_breakdown:
  implementation: "2 hours"
  testing: "1 hour"
  documentation: "30 minutes"
  total: "3.5 hours"
---
