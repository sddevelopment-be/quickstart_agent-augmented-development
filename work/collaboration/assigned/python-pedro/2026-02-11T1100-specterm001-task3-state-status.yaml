---
# Task Descriptor: SPEC-TERM-001 Task 3 - Standardize State/Status Terminology
id: "2026-02-11T1100-specterm001-task3-state-status"
title: "SPEC-TERM-001 Task 3: Standardize State/Status Terminology"
assignee: python-pedro
batch: "SPEC-TERM-001"
priority: MEDIUM
status: assigned
created: "2026-02-11T11:00:00Z"
specification: "specifications/initiatives/terminology-alignment-refactoring.md"
related_decisions:
  - "specifications/initiatives/terminology-alignment-refactoring.md"
dependencies:
  - type: prerequisite
    task_id: "2026-02-11T1100-specterm001-task2c-task-assigner"
    description: "Core class refactorings complete"
blocks:
  - "2026-02-11T1100-specterm001-task4-load-read"
estimated_hours: 8
tags:
  - spec-term-001
  - refactoring
  - state-status
  - terminology-alignment
---

# Task: Standardize State/Status Terminology

## Context

**Initiative:** SPEC-TERM-001 - Terminology Alignment Refactoring  
**Batch:** Phase 2 - Terminology Standardization  
**Strategic Goal:** Resolve State vs Status conflict per glossary definitions

**Why This Matters:**
- Current codebase uses "state" and "status" inconsistently
- Glossary defines distinct meanings:
  - **State** = logical condition (TaskState: pending, active, done)
  - **Status** = operational health (TaskStatus: healthy, degraded, failed)
- Conflating these concepts causes confusion
- Standardization improves code clarity and maintainability

## Objective

Update all occurrences of state/status to align with glossary definitions. State = logical condition, Status = operational health. Update tests, documentation, and type definitions.

## Acceptance Criteria

**MUST:**
- [ ] State = logical condition (TaskState: pending/active/done)
- [ ] Status = operational health (TaskStatus: healthy/degraded/failed)
- [ ] All variables/fields updated to use correct term
- [ ] Type definitions updated (enums, type hints)
- [ ] Tests updated
- [ ] Documentation updated
- [ ] Glossary entry clarified (if needed)
- [ ] All tests pass

**SHOULD:**
- [ ] Method names updated for consistency
- [ ] Error messages use correct terminology
- [ ] Logging uses correct terminology

**MUST NOT:**
- [ ] Change semantic meaning (State and Status are distinct concepts)
- [ ] Break existing APIs without migration path
- [ ] Conflate the two concepts

## Deliverables

1. **Updated Code:**
   - State-related fields use "state" terminology
   - Status-related fields use "status" terminology
   - Type definitions updated (StateEnum, StatusEnum)

2. **Updated Tests:**
   - Test names reflect correct terminology
   - Assertions use correct field names

3. **Updated Documentation:**
   - Docstrings clarified
   - Architecture docs updated
   - Glossary entry refined

4. **Migration Guide:**
   - `docs/migration/state-status-refactoring.md`
   - Clear examples of distinction
   - Migration checklist for team

5. **Migration Log:**
   - `work/refactoring/specterm001-task3-log.md`

## Test Plan

**Validation Strategy:**
1. Identify all occurrences of "state" and "status"
2. Categorize by semantic meaning (logical vs health)
3. Update variables/fields/types
4. Update tests
5. Run full test suite
6. Manual review of critical paths

**Test Commands:**
```bash
# Find all occurrences
grep -r "state" src/ --include="*.py" | wc -l
grep -r "status" src/ --include="*.py" | wc -l

# After refactoring
pytest tests/ -v

# Type checking
mypy src/ --strict
```

## Implementation Notes

### Distinction Examples

**State (Logical Condition):**
```python
# BEFORE (inconsistent)
task_status = "pending"  # Actually a state, not status
job_state = "running"    # OK, but needs enum

# AFTER (correct)
from enum import Enum

class TaskState(Enum):
    """Logical condition of task in workflow."""
    PENDING = "pending"       # Not started
    ACTIVE = "active"         # Currently executing
    DONE = "done"             # Completed successfully
    CANCELLED = "cancelled"   # Terminated before completion

task = Task(state=TaskState.PENDING)
```

**Status (Operational Health):**
```python
# BEFORE (inconsistent)
task_state = "failed"    # Actually a status (health), not state
health_status = "ok"     # OK, but needs enum

# AFTER (correct)
class TaskStatus(Enum):
    """Operational health status of task execution."""
    HEALTHY = "healthy"       # Executing normally
    DEGRADED = "degraded"     # Executing with issues
    FAILED = "failed"         # Execution failed
    UNKNOWN = "unknown"       # Health cannot be determined

task = Task(
    state=TaskState.ACTIVE,     # Logical condition
    status=TaskStatus.HEALTHY   # Operational health
)
```

**Combined Usage:**
```python
class Task:
    """Task with distinct state and status."""
    
    state: TaskState    # Where in workflow? (pending/active/done)
    status: TaskStatus  # How healthy? (healthy/degraded/failed)
    
    def is_executing(self) -> bool:
        """Check if task is currently executing (state check)."""
        return self.state == TaskState.ACTIVE
    
    def is_healthy(self) -> bool:
        """Check if task execution is healthy (status check)."""
        return self.status == TaskStatus.HEALTHY
    
    def should_retry(self) -> bool:
        """Retry if active but failed (combines state + status)."""
        return self.state == TaskState.ACTIVE and self.status == TaskStatus.FAILED
```

### Migration Guide Template

Create `docs/migration/state-status-refactoring.md`:

```markdown
# State vs Status: Migration Guide

## Distinction

| Term   | Meaning              | Examples                          | Use When                     |
|--------|----------------------|-----------------------------------|------------------------------|
| State  | Logical condition    | pending, active, done, cancelled  | Tracking workflow position   |
| Status | Operational health   | healthy, degraded, failed, unknown| Tracking execution health    |

## Before vs After

### Task Fields
```python
# BEFORE (conflated)
task.status = "pending"  # Confusing: state or status?

# AFTER (distinct)
task.state = TaskState.PENDING     # Logical: not started yet
task.status = TaskStatus.UNKNOWN   # Health: no execution yet
```

### Method Names
```python
# BEFORE
def get_task_status():  # Ambiguous: state or status?
    return task.status

# AFTER (explicit)
def get_task_state():    # Returns logical condition
    return task.state

def get_task_status():   # Returns operational health
    return task.status
```

## Migration Checklist

- [ ] Identify all uses of "state" in your code
- [ ] Identify all uses of "status" in your code
- [ ] Categorize: logical condition (→ state) or health (→ status)?
- [ ] Update variable/field names
- [ ] Update type hints
- [ ] Update tests
- [ ] Update documentation

## Questions?

- Is "pending" a state or status? **State** (logical condition in workflow)
- Is "failed" a state or status? **Status** (operational health outcome)
- Can a task have both? **Yes!** State = where in workflow, Status = how healthy

Example: Task in ACTIVE state with FAILED status = "currently executing, but failing"
```

### Glossary Clarification

Update `docs/glossary.md`:

```markdown
## State

**Domain:** Workflow Management  
**Definition:** Logical condition of an entity within a workflow or process.

**Examples:**
- TaskState: pending, active, done, cancelled
- AgentState: idle, busy, offline
- WorkflowState: planning, executing, complete

**Key Distinction:** State tracks *where* an entity is in a process, not *how healthy* it is.

**Related Terms:** Status (operational health, distinct from state)

---

## Status

**Domain:** Operational Health  
**Definition:** Operational health or condition of an executing entity.

**Examples:**
- TaskStatus: healthy, degraded, failed, unknown
- SystemStatus: operational, degraded, down
- ServiceStatus: available, unavailable

**Key Distinction:** Status tracks *how healthy* an entity is during execution, not *where* it is in a workflow.

**Related Terms:** State (logical condition, distinct from status)
```

### Migration Log Template

```markdown
# SPEC-TERM-001 Task 3: State/Status Refactoring Log

**Date:** 2026-02-11  
**Agent:** Backend Dev  
**Objective:** Standardize State vs Status terminology

## Semantic Analysis

### State (Logical Condition)
- TaskState enum: pending, active, done, cancelled
- AgentState enum: idle, busy, offline
(Total: X occurrences updated)

### Status (Operational Health)
- TaskStatus enum: healthy, degraded, failed, unknown
- SystemStatus enum: operational, degraded, down
(Total: Y occurrences updated)

## Files Changed

(List all files with state/status updates)

## Validation Results

- **Tests Before:** PASS (X/X)
- **Tests After:** PASS (X/X)
- **Type Checking:** PASS (0 errors)
- **Semantic Correctness:** Verified (state = logical, status = health)

## Completion

✅ State terminology standardized  
✅ Status terminology standardized  
✅ Types updated (enums)  
✅ Tests updated  
✅ Documentation updated  
✅ Migration guide created  
✅ Task 4 unblocked
```

## Risk Assessment

**RISK:** Medium (pervasive change across codebase)

**Mitigation:**
- Clear semantic distinction defined
- Migration guide for team
- Type checking catches misuse
- Tests validate correctness
- Incremental updates with validation

## Definition of Done

- [ ] State = logical condition (everywhere)
- [ ] Status = operational health (everywhere)
- [ ] Type definitions updated (StateEnum, StatusEnum)
- [ ] All variables/fields use correct term
- [ ] Tests pass (100%)
- [ ] Type checking passes
- [ ] Documentation updated
- [ ] Migration guide created
- [ ] Glossary clarified
- [ ] Migration log created
- [ ] Task 4 unblocked (Load/read)

## References

- **Specification:** `specifications/initiatives/terminology-alignment-refactoring.md`
- **Glossary:** `docs/glossary.md`

---

**Estimated Effort:** 8 hours  
**Agent:** Backend Dev  
**Batch:** SPEC-TERM-001 Phase 2  
**Priority:** ⭐⭐⭐ MEDIUM (terminology standardization)
