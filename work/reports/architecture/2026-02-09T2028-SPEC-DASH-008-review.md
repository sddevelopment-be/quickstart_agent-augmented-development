# Architectural Review: Dashboard Orphan Task Assignment (SPEC-DASH-008)

**Reviewer:** Architect Alphonso  
**Specification:** SPEC-DASH-008 v1.0.0  
**Review Date:** 2026-02-09T20:28  
**Status:** APPROVED ✅

---

## Executive Summary

**Decision:** ✅ **APPROVE** with implementation guidance

**Rationale:** Specification aligns with existing dashboard architecture, file-based orchestration patterns, and YAML comment preservation requirements. All five architectural questions from Analyst Annie have clear answers. No blocking technical risks identified.

**Risk Level:** LOW (incremental feature on proven foundation)

**Estimated Complexity:** MEDIUM (Backend: 2-3 hours, Frontend: 2-3 hours, Total: 4-6 hours)

---

## Architectural Questions from Phase 1

### Q1: YAML Library Choice for Comment Preservation

**Question:** Confirm ruamel.yaml is appropriate for comment preservation vs alternatives (PyYAML, strictyaml)?

**Answer:** ✅ **ruamel.yaml is CORRECT choice**

**Rationale:**
- **PyYAML:** Cannot preserve comments (dumps remove them)
- **strictyaml:** Preserves structure but limited comment support
- **ruamel.yaml:** Round-trip preservation of comments, whitespace, and field order

**Evidence:** Existing usage in `src/llm_service/dashboard/task_priority_updater.py` (ADR-035 implementation) already uses ruamel.yaml successfully for YAML updates.

**Decision:** Continue with ruamel.yaml. No change needed.

---

### Q2: Frontmatter Parsing Performance (<200ms for 50+ specs)

**Question:** Is <200ms achievable for 50+ specifications? Should we implement caching?

**Answer:** ✅ **Achievable WITH caching**

**Analysis:**
- **Without caching:** ~10-15ms per spec × 50 = 500-750ms (EXCEEDS 200ms target)
- **With caching:** Parse once on startup, invalidate on file change = <50ms for cached reads

**Recommendation:** Implement two-tier caching strategy:

```python
# Tier 1: In-memory cache (lifetime: process)
spec_cache = {}

# Tier 2: File watcher invalidation
file_watcher.on_change('specifications/**/*.md', invalidate_spec_cache)
```

**Performance Budget:**
- Initial load (startup): <2 seconds for 50 specs ✅ Acceptable
- Cached reads: <50ms ✅ Within budget
- Cache invalidation: <100ms ✅ Acceptable

**Implementation Note:** Use `watchdog` library for file watching (already in dependencies).

---

### Q3: Concurrent Edit Strategy (Optimistic Locking vs Last-Write-Wins)

**Question:** Optimistic locking (HTTP 409) vs last-write-wins? Which aligns better with file-based orchestration?

**Answer:** ✅ **Optimistic locking (HTTP 409 Conflict)**

**Rationale:**

**File-based orchestration principle:** Files are source of truth; conflicts must be surfaced, not silently resolved.

**Comparison:**

| Strategy | Pros | Cons | Alignment |
|----------|------|------|-----------|
| **Last-Write-Wins** | Simple implementation | Silent data loss, breaks multi-agent coordination | ❌ Poor |
| **Optimistic Locking** | Explicit conflict detection, user resolves | Requires retry UX, 50ms latency overhead | ✅ Excellent |

**Implementation:**
1. Read task file, capture `modified_time` or compute file hash
2. On PATCH request, re-read file and compare `modified_time`/hash
3. If changed: return `409 Conflict` with error message
4. Frontend: Show conflict dialog, offer "Refresh and retry"

**User Experience:**
```
❗️ This task was modified by another user. 
   Do you want to refresh and try again?
   [Refresh] [Cancel]
```

**Decision:** Implement optimistic locking via file modification time comparison.

---

### Q4: WebSocket Event Granularity

**Question:** Single `task.updated` event vs more specific `task.assigned` event?

**Answer:** ✅ **Use specific `task.assigned` event**

**Rationale:**

**Existing patterns (per ADR-037):**
- `task.created` - New task added
- `task.updated` - Task field changed (generic)
- `task.priority_changed` - Specific priority edit (ADR-035)
- `task.status_changed` - Status transition

**Recommendation:** Follow specificity pattern:

```json
{
  "event": "task.assigned",
  "task_id": "2026-02-06T1500-dashboard-orphan-assignment",
  "specification": "specifications/llm-dashboard/orphan-task-assignment.md",
  "feature": "Feature 3: Initiative Tracking",
  "timestamp": "2026-02-09T20:30:00Z"
}
```

**Benefits:**
1. Clients can filter events (e.g., only refresh portfolio on assignment/status changes)
2. Audit trail clarity (specific event types in logs)
3. Future: Enable event-driven workflows (e.g., notify specification owner on task assignment)

**Decision:** Emit `task.assigned` event (specific) + `task.updated` event (generic) for backward compatibility.

---

### Q5: Feature Field Format (ID vs Title)

**Question:** Should `feature:` store feature ID (`FEAT-DASH-008-01`) or title (`"Orphan Task Detection"`)? Title chosen for readability - confirm?

**Answer:** ✅ **Use TITLE (human-readable)**

**Rationale:**

**Trade-off Analysis:**

| Approach | Pros | Cons | Decision |
|----------|------|------|----------|
| **Feature ID** | Stable (survives title changes), machine-friendly | Requires lookup for display, not human-readable in YAML | ❌ |
| **Feature Title** | Human-readable in YAML, no lookup needed | Breaks if title changes, requires spec re-parse | ✅ |

**Context:** File-based orchestration prioritizes **human readability** over machine efficiency. Tasks are primarily read/edited by humans; YAML files should be self-documenting.

**Example YAML (Title approach):**
```yaml
id: 2026-02-09T1430-add-syntax-highlighting
title: Add syntax highlighting for code blocks
specification: specifications/llm-dashboard/markdown-rendering.md
feature: "Feature 2: Selective Field Rendering"  # ✅ Self-documenting
agent: frontend-freddy
```

**Mitigation for Title Changes:**
- Specification frontmatter defines features; title changes should be rare
- If feature title changes, run migration script to update task YAMLs (future enhancement)
- For now, accept manual update burden (low frequency)

**Decision:** Store feature TITLE (human-readable). Document title stability requirement in specification guidelines.

---

## Architectural Assessment

### Integration with Existing Systems

**✅ Dashboard Architecture (ADR-037)**
- Modal UI pattern consistent with existing task priority editing (ADR-035)
- WebSocket event system already established
- Portfolio API structure supports hierarchical display
- No new architectural components needed

**✅ File-Based Orchestration (ADR-002, ADR-003)**
- YAML as source of truth preserved
- Comment preservation via ruamel.yaml (proven pattern)
- Atomic file writes (temp → rename) already implemented
- Task lifecycle state machine unchanged

**✅ Specification Framework (Directive 034, 035)**
- Specification frontmatter parsing consistent with existing validation
- Feature array structure already defined in Directive 035
- No new frontmatter fields required

### Technical Risks & Mitigations

**Risk 1: Frontmatter Parsing Performance**
- **Severity:** MEDIUM
- **Impact:** Modal load time >500ms at scale (50+ specs)
- **Mitigation:** ✅ Implement caching (detailed in Q2 above)
- **Residual Risk:** LOW

**Risk 2: Concurrent Edit Conflicts**
- **Severity:** MEDIUM
- **Impact:** Data loss if two users assign same task simultaneously
- **Mitigation:** ✅ Optimistic locking (detailed in Q3 above)
- **Residual Risk:** LOW (user resolves via retry dialog)

**Risk 3: Malformed Specification YAML**
- **Severity:** LOW
- **Impact:** Feature list missing/invalid → modal shows degraded state
- **Mitigation:** ✅ Graceful degradation (NFR-R2) - skip invalid spec, log error, show user notice
- **Residual Risk:** LOW

**Risk 4: Feature Title Instability**
- **Severity:** LOW
- **Impact:** Task references outdated feature title after spec change
- **Mitigation:** ⚠️ Document feature title stability requirement; accept manual migration for now
- **Residual Risk:** LOW (feature titles rarely change)

**Overall Risk:** ✅ **LOW** - All risks mitigated or accepted with low residual impact

---

## Trade-Off Analysis

### Alternative Approaches Considered

**Alternative 1: Database-Backed Assignment (REJECTED)**

**Pros:**
- Faster queries
- Easier concurrent edit handling
- Built-in transaction support

**Cons:**
- ❌ Breaks file-based orchestration principle
- ❌ Introduces state synchronization complexity
- ❌ Reduces Git audit trail clarity
- ❌ Requires database migration infrastructure

**Decision:** REJECT - File-based orchestration is core architectural constraint

---

**Alternative 2: Feature ID Instead of Title (REJECTED)**

See Q5 analysis above. **Rejected** due to reduced YAML human-readability.

---

**Alternative 3: Automatic Specification Frontmatter Update (REJECTED)**

**Proposal:** Automatically add `assigned_tasks: [task-id-1, task-id-2]` to specification frontmatter during assignment.

**Pros:**
- Bidirectional linking (task → spec, spec → tasks)
- Easier "show all tasks for this spec" query

**Cons:**
- ❌ Specifications are authoritative documents requiring human review (per FR-W2)
- ❌ Creates circular dependency (task writes trigger spec reads trigger task writes...)
- ❌ Git conflicts on specification file increase dramatically

**Decision:** REJECT - Keep specifications as read-only from assignment workflow. Accept unidirectional linking (task → spec only).

---

## Implementation Guidance

### Backend Architecture

**Endpoint:**
```python
@app.route('/api/tasks/<task_id>/specification', methods=['PATCH'])
def update_task_specification(task_id):
    """
    Assign orphan task to specification/feature.
    
    Request:
        {
            "specification": "specifications/llm-dashboard/orphan-task-assignment.md",
            "feature": "Feature 2: Interactive Selector"  # Optional
        }
    
    Response 200:
        {
            "success": true,
            "task": { ... }  # Updated task object
        }
    
    Errors:
        400: Invalid specification path or task not found
        409: Concurrent edit conflict (optimistic locking)
        500: YAML write failure
    """
    pass
```

**Implementation Steps:**
1. Validate specification path (whitelist `specifications/**/*.md`)
2. Check specification file exists
3. Load task YAML with ruamel.yaml
4. Check task status (block if `in_progress`, `done`, `failed`)
5. Read current file modification time (optimistic lock)
6. Update `specification:` and `feature:` fields
7. Write atomically (temp file → rename)
8. Verify YAML integrity (round-trip test)
9. Emit WebSocket events: `task.assigned` + `task.updated`
10. Return success response

**Reuse Existing Code:**
- `src/llm_service/dashboard/task_priority_updater.py` - YAML writing patterns
- `src/llm_service/dashboard/app.py` - WebSocket emission patterns
- `src/llm_service/dashboard/portfolio_builder.py` - Specification frontmatter parsing

---

### Frontend Architecture

**Modal Component Structure:**
```
AssignmentModal
  ├── TaskPreview (title, agent, priority)
  ├── SearchBar (filter initiatives/features)
  ├── InitiativeList
  │   ├── InitiativeItem (expandable)
  │   │   ├── FeatureList
  │   │   │   ├── FeatureItem (selectable)
  │   │   │   └── AssignButton
  ├── ConflictDialog (on HTTP 409)
  └── SuccessToast
```

**State Management:**
```javascript
const [initiatives, setInitiatives] = useState([]);  // Cached spec list
const [searchQuery, setSearchQuery] = useState('');
const [selectedFeature, setSelectedFeature] = useState(null);
const [isLoading, setIsLoading] = useState(false);
```

**Performance Optimization:**
- Load specification list on modal open (not per-task)
- Cache initiative list in browser session storage (invalidate on refresh)
- Client-side search filtering (no backend round-trip)

---

### Testing Strategy

**Unit Tests (Backend):**
1. Specification path validation (whitelist enforcement)
2. Optimistic locking conflict detection
3. YAML comment preservation round-trip
4. Task status blocking (in_progress → reject)
5. Atomic file write (temp → rename)

**Integration Tests:**
1. End-to-end assignment flow (orphan → assigned)
2. WebSocket event emission verification
3. Concurrent assignment conflict simulation
4. Malformed specification graceful degradation

**Acceptance Tests (ATDD):**
- AC1: Assign orphan task to feature via modal ✅
- AC2: Prevent assignment of in-progress tasks ✅
- (See specification for full list)

**Performance Tests:**
1. Modal load time <500ms (P95)
2. Frontmatter parsing <200ms per spec
3. YAML write operation <300ms (P95)

---

## Feasibility Assessment

**Technical Feasibility:** ✅ **HIGH**
- All required components exist (YAML handling, WebSocket, modal UI)
- Patterns established in prior features (ADR-035, ADR-037)
- No new dependencies required
- Incremental enhancement on proven foundation

**Implementation Complexity:** ✅ **MEDIUM**
- Backend: 2-3 hours (endpoint + validation + caching)
- Frontend: 2-3 hours (modal UI + API integration)
- Testing: 1-2 hours (unit + integration)
- **Total: 5-8 hours** (within specification estimate of 6-8 hours for Option 2)

**Maintenance Burden:** ✅ **LOW**
- Reuses existing patterns (low cognitive overhead)
- No new infrastructure components
- File-based orchestration simplifies debugging

---

## Architectural Decision

**Status:** ✅ **APPROVED**

**Recommendation:** Proceed to Phase 3 (Planning) with Planning Petra.

**Implementation Approach:** Feature-level assignment (Option 2 from feature request document) as specified in SPEC-DASH-008.

**Key Decisions:**
1. Use ruamel.yaml for comment preservation ✅
2. Implement frontmatter caching with file watcher invalidation ✅
3. Optimistic locking (HTTP 409) for concurrent edit conflict resolution ✅
4. Emit specific `task.assigned` event (+ generic `task.updated` for compatibility) ✅
5. Store feature TITLE (human-readable) in YAML ✅

**Open Questions for Planning Petra:**
1. Should bulk assignment (FR-S3) be included in MVP or deferred to v2?
2. Assign Backend work to Python Pedro or Backend Benny?
3. Should Frontend and Backend tasks be sequential or parallel?

---

## Handoff to Phase 3

**To:** Planning Petra

**Summary:** SPEC-DASH-008 architecturally sound and approved for implementation. Technical feasibility confirmed, risks mitigated, implementation guidance provided. Estimated 5-8 hours total effort.

**Decomposition Guidance:**
- **Task 1:** Backend endpoint (`/api/tasks/:id/specification` PATCH) - 2-3h
- **Task 2:** Frontmatter caching + file watcher - 1h
- **Task 3:** Frontend modal UI - 2-3h
- **Task 4:** Integration testing + ATDD - 1-2h

**Agent Assignment Recommendation:**
- Backend: Python Pedro (dashboard expertise + YAML handling experience)
- Frontend: Frontend agent (modal UI patterns)
- Testing: Same agents (per ATDD/TDD workflow)

**Next Step:** Create task YAML files in `work/collaboration/inbox/` with detailed acceptance criteria.

---

✅ **Phase 2 Complete** - Architecture approved, ready for planning
